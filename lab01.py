import numpy as np
import matplotlib.pyplot as plt

from matplotlib import rcParams
rcParams['font.family'] = 'Hei'

x1 = np.linspace(0, 10, 400) 

plt.figure(figsize=(10, 8))

# 约束1: x2 >= (12 - 2x1) / 5
y1 = (12 - 2 * x1) / 5
plt.plot(x1, y1, label=r'$2x_1 + 5x_2 \geq 12$')

# 约束2: x2 <= (8 - x1) / 2
y2 = (8 - x1) / 2
plt.plot(x1, y2, label=r'$x_1 + 2x_2 \leq 8$')

# 约束3: x1 <= 4
plt.axvline(x=4, color='gray', linestyle='--', label=r'$x_1 \leq 4$')
# 约束 x1 >= 0 
plt.axvline(x=0, color='gray', linestyle=':', label=r'$x_1 \geq 0$')


# 约束4: x2 <= 3
plt.axhline(y=3, color='purple', linestyle='--', label=r'$x_2 \leq 3$')
# 约束 x2 >= 0 
plt.axhline(y=0, color='purple', linestyle=':', label=r'$x_2 \geq 0$')


plt.xlim(0, 6) # 根据题目中的图调整范围
plt.ylim(0, 5) # 根据题目中的图调整范围

d = np.linspace(-2, 8, 300)
x1_fill, x2_fill = np.meshgrid(d, d)

feasible_region = (
    (2 * x1_fill + 5 * x2_fill >= 12) &
    (x1_fill + 2 * x2_fill <= 8) &
    (x1_fill >= 0) & (x1_fill <= 4) &
    (x2_fill >= 0) & (x2_fill <= 3)
)
plt.imshow(
    feasible_region.astype(int),
    extent=(x1_fill.min(), x1_fill.max(), x2_fill.min(), x2_fill.max()),
    origin="lower",
    cmap="Greens",
    alpha=0.3,
)


# 找到可行域的顶点
p1 = (2, 3)
p2 = (4, 3) # 这个点不满足 x1 + 2x2 <= 8 (4 + 6 = 10 > 8), 所以它不是可行域顶点
            # 修正：x1=4 与 x1+2x2=8 的交点
            # 4 + 2x2 = 8 => 2x2 = 4 => x2 = 2. 点 (4, 2)
p2_revised = (4, 2)

# 交点3: x1 = 4 和 2x1 + 5x2 = 12
# 2*4 + 5x2 = 12 => 8 + 5x2 = 12 => 5x2 = 4 => x2 = 4/5 = 0.8. 点 (4, 0.8)
p3 = (4, 0.8)

# 交点4: x1 + 2x2 = 8 和 2x1 + 5x2 = 12
# 从 x1 + 2x2 = 8 => x1 = 8 - 2x2
# 代入: 2(8 - 2x2) + 5x2 = 12
# 16 - 4x2 + 5x2 = 12
# 16 + x2 = 12 => x2 = -4 (不在 x2>=0 范围, 忽略)
# 检查代数：
# x1 = 8 - 2x2
# 2(8-2x2) + 5x2 = 12
# 16 - 4x2 + 5x2 = 12
# 16 + x2 = 12
# x2 = 12 - 16 = -4.  这说明这两条线在 x2<0 的地方相交，或者我理解错了图。
# 让我们重新检查图中的可行域。
# 观察PDF中的图，顶点似乎是：
# A: (2x1+5x2=12) 和 (x2=3) 的交点。 2x1 + 15 = 12 => 2x1 = -3 => x1 = -1.5. 这个点不在 x1>=0.
#   这意味着 x2=3 这条线在可行域的“上方”切割。
# B: (x1+2x2=8) 和 (x2=3) 的交点。 x1 + 6 = 8 => x1 = 2.  顶点 B = (2, 3)
# C: (x1+2x2=8) 和 (x1=4) 的交点。 4 + 2x2 = 8 => 2x2 = 4 => x2 = 2. 顶点 C = (4, 2)
# D: (2x1+5x2=12) 和 (x1=4) 的交点。 8 + 5x2 = 12 => 5x2 = 4 => x2 = 0.8. 顶点 D = (4, 0.8)
# E: (2x1+5x2=12) 和 (x2= (12-2x1)/5 与 x1 轴的交点，即 x2=0)
#    2x1 = 12 => x1 = 6. 点 (6,0). 但 x1<=4, 所以这个点不是。
#    (2x1+5x2=12) 和 (x1 轴 x2=0) 的交点是 (6,0)
#    (x1+2x2=8) 和 (x1 轴 x2=0) 的交点是 (8,0)
#    (2x1+5x2=12) 和 (x2 轴 x1=0) 的交点是 (0, 2.4)
#    (x1+2x2=8) 和 (x2 轴 x1=0) 的交点是 (0, 4) -> 但 x2<=3, 所以是 (0,3)

# 根据PDF图和约束，可行域的顶点应该是：
# 1. (x1+2x2=8) 与 (x2=3) 的交点: x1+6=8 => x1=2.  V1 = (2, 3)
# 2. (x1+2x2=8) 与 (x1=4) 的交点: 4+2x2=8 => 2x2=4 => x2=2. V2 = (4, 2)
# 3. (2x1+5x2=12) 与 (x1=4) 的交点: 8+5x2=12 => 5x2=4 => x2=0.8. V3 = (4, 0.8)
# 4. (2x1+5x2=12) 与 (x1=(12-5x2)/2). 这个点需要与其他边界相交。
#    观察图像，另一个相关的点是 (2x1+5x2=12) 和 (x1+2x2=8) 的交点，如果它在界内。
#    x1 = 8 - 2x2
#    2(8-2x2) + 5x2 = 12
#    16 - 4x2 + 5x2 = 12
#    16 + x2 = 12 => x2 = -4. 这个交点在可行域之外。

# 让我们重新审视可行域的边界。
# 下界: y_lower = (12-2x1)/5 和 y=0 (取较大者)
# 上界: y_upper = (8-x1)/2 和 y=3 (取较小者)
# 同时 x1 在 [0, 4] 之间

# 可行域的顶点 (手动从图中和约束推断):
# 顶点A: x1+2x2=8 与 x2=3 交点
#   x1 + 2*3 = 8 => x1 = 2.  A = (2, 3)
# 顶点B: x1+2x2=8 与 x1=4 交点
#   4 + 2*x2 = 8 => 2x2 = 4 => x2 = 2. B = (4, 2)
# 顶点C: 2x1+5x2=12 与 x1=4 交点
#   2*4 + 5*x2 = 12 => 8 + 5*x2 = 12 => 5*x2 = 4 => x2 = 0.8. C = (4, 0.8)
# 顶点D: 2x1+5x2=12 与 x1 轴 (x2=0) 的交点是 (6,0)，但 x1<=4，所以不是。
#   2x1+5x2=12 与 x2 轴 (x1=0) 的交点是 (0, 2.4). D = (0, 2.4)
#   这个点需要检查是否满足 x1+2*2.4 <= 8 (4.8 <= 8, 满足)
#   以及 0 <= 2.4 <= 3 (满足)
# 顶点E: x1+2x2=8 与 x2 轴 (x1=0) 的交点是 (0,4)，但 x2<=3, 所以是 (0,3). E = (0,3)

# 筛选后，根据图示的可行域形状，顶点应该是：
# (2,3)
# (4,2)
# (4, 0.8)
# 还有 (12-5*0)/2 = 6. x1=6, x2=0. 但 x1<=4.
# 考虑 x1 轴上的点：
#   如果 x2=0, 2x1 >= 12 => x1 >= 6. 与 x1<=4 矛盾。所以可行域不接触 x1 轴在 x1>0 的部分，除非在原点附近。
#   如果 x2=0, x1 <= 8.
# 考虑 x2 轴上的点：
#   如果 x1=0, 5x2 >= 12 => x2 >= 2.4.
#   如果 x1=0, 2x2 <= 8 => x2 <= 4.
#   结合 x2 <= 3. 所以在 x2 轴上，可行域是 [2.4, 3].
#   所以 (0, 2.4) 和 (0, 3) 是可行域边界上的点。

vertices = []
# 交点 1: x1 + 2x2 = 8 and x2 = 3
x1_v = 8 - 2*3
if 0 <= x1_v <= 4:
    vertices.append((x1_v, 3)) # (2, 3)

# 交点 2: x1 + 2x2 = 8 and x1 = 4
x2_v = (8 - 4) / 2
if 0 <= x2_v <= 3: # 检查是否满足 x2 的约束
    vertices.append((4, x2_v)) # (4, 2)

# 交点 3: 2x1 + 5x2 = 12 and x1 = 4
x2_v = (12 - 2*4) / 5
if 0 <= x2_v <= 3: # 检查是否满足 x2 的约束
     # 并且这个点也需要满足 x1 + 2x2 <= 8  => 4 + 2*0.8 = 4 + 1.6 = 5.6 <= 8 (满足)
    vertices.append((4, x2_v)) # (4, 0.8)

# 交点 4: 2x1 + 5x2 = 12 and x2 = 0 (与x1轴的交点)
# x1_v = 12 / 2 = 6 (不满足 x1 <= 4)

# 交点 5: 2x1 + 5x2 = 12 and x1 = 0 (与x2轴的交点)
x2_v = 12 / 5
if 0 <= x2_v <= 3: # 检查是否满足 x2 的约束
    # 并且这个点也需要满足 x1 + 2x2 <= 8 => 0 + 2*2.4 = 4.8 <= 8 (满足)
    vertices.append((0, x2_v)) # (0, 2.4)

# 交点 6: x1 + 2x2 = 8 and x1 = 0 (与x2轴的交点)
# x2_v = 8 / 2 = 4 (不满足 x2 <= 3)
# 但是 x1=0 和 x2=3 是一个可能的边界点
if (0 + 2*3 <= 8) and (2*0 + 5*3 >=12): # (0,3) -> 6 <= 8 (T), 15 >= 12 (T)
    vertices.append((0,3))

# 交点 7: x1=0, x2=0 (原点)
# 2*0 + 5*0 >= 12 (False) -> 原点不可行

# 手动确认PDF图中的顶点 (近似值):
# (0, 2.4), (0, 3), (2, 3), (4, 2), (4, 0.8)
# 这些点需要满足所有约束条件
# (0, 2.4): 2*0+5*2.4 = 12 >= 12 (T); 0+2*2.4 = 4.8 <= 8 (T); 0<=0<=4 (T); 0<=2.4<=3 (T). 可行.
# (0, 3):   2*0+5*3 = 15 >= 12 (T); 0+2*3 = 6 <= 8 (T); 0<=0<=4 (T); 0<=3<=3 (T). 可行.
# (2, 3):   2*2+5*3 = 4+15 = 19 >= 12 (T); 2+2*3 = 8 <= 8 (T); 0<=2<=4 (T); 0<=3<=3 (T). 可行.
# (4, 2):   2*4+5*2 = 8+10 = 18 >= 12 (T); 4+2*2 = 8 <= 8 (T); 0<=4<=4 (T); 0<=2<=3 (T). 可行.
# (4, 0.8): 2*4+5*0.8 = 8+4 = 12 >= 12 (T); 4+2*0.8 = 4+1.6 = 5.6 <= 8 (T); 0<=4<=4 (T); 0<=0.8<=3 (T). 可行.

final_vertices = list(set(vertices)) # 去重
# 确保顶点顺序以便绘制多边形 (可选，但有助于可视化)
# 简单的排序可能不适用于非凸多边形，但这里是凸的
# final_vertices.sort(key=lambda p: (p[0], p[1])) # 简单排序

# 重新定义顶点，确保它们是可行域的真实角点
# 按照PDF图的形状，顶点是：
# P_A = (0, 3)
# P_B = (2, 3)  (x1+2x2=8 与 x2=3)
# P_C = (4, 2)  (x1+2x2=8 与 x1=4)
# P_D = (4, 0.8) (2x1+5x2=12 与 x1=4)
# P_E = (0, 2.4) (2x1+5x2=12 与 x1=0)

# 筛选出真正构成可行域边界的顶点
# 1. (0, 2.4)
# 2. (0, 3)
# 3. (2, 3)
# 4. (4, 2)
# 5. (4, 0.8)

# 检查这些点是否满足所有约束
points_to_check = [
    (0, 2.4), (0, 3), (2, 3), (4, 2), (4, 0.8)
]
valid_vertices = []
for p_x, p_y in points_to_check:
    if (2*p_x + 5*p_y >= 12 - 1e-9) and \
       (p_x + 2*p_y <= 8 + 1e-9) and \
       (0 - 1e-9 <= p_x <= 4 + 1e-9) and \
       (0 - 1e-9 <= p_y <= 3 + 1e-9):
        valid_vertices.append((p_x, p_y))

# 绘制顶点
if valid_vertices:
    vx, vy = zip(*valid_vertices)
    plt.plot(vx, vy, 'ro', label='可行域顶点') # 红色圆点标记顶点

    # 目标函数: z = 2x1 + x2
    # x2 = z - 2x1
    max_z = -np.inf
    optimal_point = None

    print("可行域顶点及其目标函数值:")
    for p_x, p_y in valid_vertices:
        z_value = 2 * p_x + p_y
        print(f"点 ({p_x:.2f}, {p_y:.2f}): z = {z_value:.2f}")
        if z_value > max_z:
            max_z = z_value
            optimal_point = (p_x, p_y)

    print(f"\n最优解:")
    if optimal_point:
        print(f"在点 ({optimal_point[0]:.2f}, {optimal_point[1]:.2f}) 处取得最大值")
        print(f"最大值 z = {max_z:.2f}")

        # 绘制最优目标函数线
        x_opt_line = np.linspace(0, 5, 100)
        y_opt_line = max_z - 2 * x_opt_line
        plt.plot(x_opt_line, y_opt_line, 'k--', label=f'最优目标函数 $z={max_z:.2f}$')
        plt.plot(optimal_point[0], optimal_point[1], 'g*', markersize=15, label=f'最优点 ({optimal_point[0]:.2f}, {optimal_point[1]:.2f})')

else:
    print("没有找到有效的可行域顶点。请检查约束条件。")


# 添加图例和标签
plt.xlabel('$x_1$')
plt.ylabel('$x_2$')
plt.title('线性规划图解法')
plt.legend(loc='upper right')
plt.grid(True)
plt.axhline(0, color='black',linewidth=0.5)
plt.axvline(0, color='black',linewidth=0.5)
plt.show()

